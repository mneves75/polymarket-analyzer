# Polymarket Analyzer - Engineering Execution Spec

> **Status:** Active | **Created:** 2026-01-06 | **Owner:** Development Team
>
> **"John Carmack is reviewing this. Make it count."**

---

## Document Overview

This is a **living execution specification** that will be updated as work progresses. It represents the comprehensive plan to bring the polymarket-analyzer documentation and codebase to industry-leading standards.

### Phase Structure

- **Phase 1:** Complete Missing Documentation (Week 1)
- **Phase 2:** Code Quality & Documentation (Week 2)
- **Phase 3:** Testing & Observability (Week 3)
- **Phase 4:** Polish & Validation (Week 4)

---

## Phase 1: Complete Missing Documentation (Week 1)

**Goal:** 100% completion of all documentation sections

### Sprint 1.1: Complete Chapter 05 (TUI)

**File:** `docs/learn/05-interface-terminal.md`

**Tasks:**
1. [ ] Add Checkpoints section (3-5 questions)
2. [ ] Add Common Pitfalls section (5-7 pitfalls)
3. [ ] Add Troubleshooting section (5-7 issues)
4. [ ] Add Design Decisions section (3-4 decisions)
5. [ ] Add External Resources section (5-7 links)
6. [ ] Fix code reference errors (verify utils.ts location)
7. [ ] Add "Run This" sections to all code examples

**Checkpoint Questions Draft:**
```markdown
## ‚úÖ Checkpoint

1. Qual √© a principal diferen√ßa entre CLI, TUI e GUI?
2. Como voc√™ cria um componente b√°sico com Blessed?
3. O que √© smartCSR e quando voc√™ deve us√°-lo?
4. Como voc√™ captura entrada de teclado em Blessed?
5. Qual √© a diferen√ßa entre tags like {bold} e style.fg?
```

**Common Pitfalls Draft:**
```markdown
## ‚ö†Ô∏è Common Pitfalls

### Pitfall 1: Esquecer screen.render()
**Problem:** Voc√™ adiciona componentes mas n√£o v√™ nada na tela.
**Solution:** Sempre chame screen.render() ap√≥s modificar componentes.

### Pitfall 2: Memory Leaks com Timers
**Problem:** setInterval nunca √© limpo, causando memory leaks.
**Solution:** Sempre guarde refer√™ncias a timers e limpe no cleanup.

### Pitfall 3: Layout Fixo vs Responsivo
**Problem:** Usar posi√ß√µes fixas (top: 10) quebram em terminais pequenos.
**Solution:** Use posi√ß√µes relativas (top: "30%") quando poss√≠vel.

### Pitfall 4: Muitas Renders
**Problem:** Chamar screen.render() a cada mensagem WebSocket causa lag.
**Solution:** Implemente rate limiting ou requestAnimationFrame.

### Pitfall 5: Ignorar Unicode/UTF-8
**Problem:** Caracteres especiais aparecem quebrados.
**Solution:** Configure locale e encoding corretamente.

### Pitfall 6: Sair sem Cleanup
**Problem:** WebSocket fica aberto, timers continuam rodando.
**Solution:** Sempre implemente cleanup em process.on('SIGTERM').

### Pitfall 7: Cores N√£o Port√°veis
**Problem:** Cores funcionam em um terminal mas n√£o em outro.
**Solution:** Teste em m√∫ltiplos terminais, use cores b√°sicas (16 cores).
```

**Troubleshooting Draft:**
```markdown
## üîß Troubleshooting

### Issue: "Cannot find module 'blessed'"
**Symptoms:** Erro ao executar bun run dev
**Diagnosis:** Depend√™ncia n√£o instalada
**Solution:**
```bash
rm -rf node_modules
bun install
```

### Issue: TUI aparece distorcida
**Symptoms:** Linhas n√£o se alinham, texto sobreposto
**Diagnosis:** Terminal muito pequeno ou fonte n√£o monoespa√ßada
**Solution:**
- Aumente o tamanho do terminal (m√≠nimo 80x24)
- Use fonte monoespa√ßada (Courier, Consolas, etc.)

### Issue: Teclas n√£o funcionam
**Symptoms:** Pressionar teclas n√£o faz nada
**Diagnosis:** Foco no componente errado ou key binding incorreto
**Solution:**
- Verifique se screen.key() est√° correto
- Use o nome da tecla correto (ex: "C-c" n√£o "ctrl-c")

### Issue: Performance lenta
**Symptoms:** TUI trava ao atualizar
**Diagnosis:** Muitas renders ou processamento pesado
**Solution:**
- Implemente render throttling
- Mova processamento pesado para worker threads

### Issue: WebSocket reconecta infinitamente
**Symptoms:** Mensagem "reconnecting" aparece constantemente
**Diagnosis:** URL incorreta ou servidor fora do ar
**Solution:**
- Verifique CONFIG.clobWsBase
- Teste conex√£o com wscat ou ferramenta similar

### Issue: Dados n√£o atualizam
**Symptoms:** Valores ficam est√°ticos mesmo com WebSocket conectado
**Diagnosis:** Event handler n√£o registrado ou assetId incorreto
**Solution:**
- Verifique se onUpdate est√° sendo chamado
- Confirme assetId corresponde ao token esperado

### Issue: Erro "content is not a function"
**Symptoms:** Erro ao tentar atualizar conte√∫do
**Diagnosis:** Tentando usar .content() em vez de .setContent()
**Solution:** Use setContent(string) n√£o content()
```

**Design Decisions Draft:**
```markdown
## üéì Design Decisions

### Decis√£o 1: Por que TUI (Terminal UI) em vez de GUI?

**Alternativas Consideradas:**
1. Web App (React/Next.js) - Interface web moderna
2. Desktop App (Electron) - Aplica√ß√£o desktop nativa
3. CLI Simples - Apenas comandos sem interface visual
4. TUI (Blessed) - Interface no terminal ‚úÖ **ESCOLHIDO**

**Trade-offs:**

| Crit√©rio | Web App | Electron | CLI | TUI | Vencedor |
|----------|---------|----------|-----|-----|----------|
| Facilidade de SSH | ‚ùå Dif√≠cil | ‚ùå Imposs√≠vel | ‚úÖ F√°cil | ‚úÖ F√°cil | TUI |
| Performance | ‚ö†Ô∏è Browser overhead | ‚ùå Pesado | ‚úÖ Leve | ‚úÖ Leve | TUI |
| Distribui√ß√£o | ‚ö†Ô∏è Servidor required | ‚ö†Ô∏è Bin√°rio grande | ‚úÖ Single binary | ‚úÖ Single binary | TUI |
| Visual rico | ‚úÖ HTML/CSS | ‚úÖ HTML/CSS | ‚ùå Sem visual | ‚ö†Ô∏è Limitado | Web |
| Apar√™ncia "hacker" | ‚ùå Corporate | ‚ùå App comum | ‚ö†Ô∏è Simples | ‚úÖ Premium | TUI |
| Recursos de sistema | ‚ö†Ô∏è Limitado | ‚úÖ Acesso total | ‚úÖ Acesso total | ‚úÖ Acesso total | Empate |

**Por que TUI foi escolhido:**
- ‚úÖ Foco em servidores: Muito uso em ambientes remotos via SSH
- ‚úÖ Leveza: Sem overhead de navegador/Electron
- ‚úÖ Distribui√ß√£o: Single binary, f√°cil de instalar
- ‚úÖ Est√©tica: Apar√™ncia "hacker profissional"
- ‚úÖ Performance: Renderiza√ß√£o instant√¢nea

**Cen√°rios onde outras op√ß√µes seriam melhores:**
- Web App: Para usu√°rios n√£o-t√©cnicos que preferem interface visual
- Electron: Se precisasse de recursos gr√°ficos avan√ßados
- CLI: Para automa√ß√£o e scripts

### Decis√£o 2: Por que Blessed em vez de alternativas?

**Alternativas Consideradas:**
1. Blessed - Biblioteca ncurses para Node.js ‚úÖ **ESCOLHIDO**
2. Ink - React para CLIs
3. Terminal-kit - Biblioteca alternativa
4. Raw ANSI codes - Sem biblioteca

**Por que Blessed:**
- ‚úÖ Maduro: Est√°vel h√° anos, amplamente usado
- ‚úÖ Simples: API direta sem camadas de abstra√ß√£o
- ‚úÖ Completo: Suporta layouts, mouse, forms
- ‚úÖ Documenta√ß√£o: Muitos exemplos e tutoriais
- ‚úÖ Compatibilidade: Funciona em Node.js e Bun

**Por que n√£o Ink:**
- Requer conhecimento de React
- Overhead para projeto simples
- Abstra√ß√£o desnecess√°ria

**Por que n√£o Terminal-kit:**
- Menos popular/menos recursos
- API diferente/mais complexa

### Decis√£o 3: Layout de 8 pain√©is ou layout simples?

**Abordagens:**
1. Single panel - Mostra apenas uma coisa por vez
2. Two panels - Radar + detalhe do mercado
3. Eight panels - Radar, Market, Pulse, Orderbook, History, Holders, Alerts, Footer ‚úÖ **ESCOLHIDO**

**Por que 8 pain√©is:**
- ‚úÖ Visibilidade completa: Tudo importante vis√≠vel de uma vez
- ‚úÖ Efici√™ncia: Sem necessidade de navegar entre telas
- ‚úÖ Monitoramento: Veja m√∫ltiplos mercados simultaneamente
- ‚úÖ Profissional: Parece uma ferramenta de trading real

**Trade-offs:**
- ‚ùå Complexidade: Mais c√≥digo para gerenciar
- ‚ùå Espa√ßo: Requer terminal maior (m√≠nimo 80x24 recomendado 120x40)
- ‚ùå Aprendizado: Mais informa√ß√µes para processar

### Decis√£o 4: Atualiza√ß√£o cont√≠nua ou on-demand?

**Abordagens:**
1. Polling cont√≠nuo - Atualiza a cada X segundos automaticamente ‚úÖ **ESCOLHIDO**
2. On-demand - S√≥ atualiza quando usu√°rio pressionar 'r'
3. H√≠brido - Algumas coisas cont√≠nuas, outras on-demand

**Por que Polling Cont√≠nuo:**
- ‚úÖ Tempo real: Dados sempre frescos
- ‚úÖ Conveni√™ncia: Usu√°rio n√£o precisa fazer nada
- ‚úÖ WebSocket: J√° recebemos updates em tempo real

**Estrat√©gia de atualiza√ß√£o:**
- Radar: 60 segundos (muda pouco)
- Orderbook: 3 segundos (muda muito)
- History: 30 segundos (dados hist√≥ricos)
- Holders: 60 segundos (muda pouco)
- WebSocket: Imediato (push)
```

### Sprint 1.2: Complete Chapter 06 (Erros & Rate Limiting)

**File:** `docs/learn/06-erros-rate-limiting.md`

**Tasks:**
1. [ ] Add Checkpoints section (3-5 questions)
2. [ ] Add Common Pitfalls section (5-7 pitfalls)
3. [ ] Add Troubleshooting section (5-7 issues)
4. [ ] Add Design Decisions section (3-4 decisions)
5. [ ] Add External Resources section (5-7 links)
6. [ ] Add "Run This" sections to all code examples

**Common Pitfalls Draft:**
```markdown
## ‚ö†Ô∏è Common Pitfalls

### Pitfall 1: "Engolir" Erros (Silent Failures)
**Problem:**
```typescript
try {
  await riskyOperation();
} catch (err) {
  // Nada - erro silencioso
}
```
**Why it's bad:** Voc√™ nunca sabe que algo falhou.
**Solution:**
```typescript
try {
  await riskyOperation();
} catch (err) {
  logger.error("Opera√ß√£o falhou", { error: err });
  throw err;  // Propaga para chamador
}
```

### Pitfall 2: Retry Infinito
**Problem:** Retry sem limite m√°ximo causa loop infinito.
**Solution:** Sempre tenha max retries e timeout total.

### Pitfall 3: Backoff Sem Jitter
**Problem:** M√∫ltiplos clientes sincronizam retries.
**Solution:** Adicione jitter aleat√≥rio ao backoff.

### Pitfall 4: Ignorar Rate Limits
**Problem:** Assumir que API n√£o tem rate limit.
**Solution:** Implemente rate limiting proativamente.

### Pitfall 5: Timeout Muito Longo
**Problem:** Timeout de 60 segundos congela a aplica√ß√£o.
**Solution:** Use timeouts curtos (5-10s) com retry.

### Pitfall 6: N√£o Logar Contexto
**Problem:** Logar apenas "Error: undefined"
**Solution:** Logar endpoint, par√¢metros, tentativas, etc.

### Pitfall 7: Exponential Backoff Errado
**Problem:** Cresce muito r√°pido (2^10 = 1024x)
**Solution:** Cap em tempo m√°ximo e limite de tentativas.
```

### Sprint 1.3: Complete Chapter 07 (Testes)

**File:** `docs/learn/07-testes.md`

**Tasks:**
1. [ ] Add Checkpoints section (3-5 questions)
2. [ ] Add Common Pitfalls section (5-7 pitfalls)
3. [ ] Add Troubleshooting section (5-7 issues)
4. [ ] Add Design Decisions section (3-4 decisions)
5. [ ] Add External Resources section (5-7 links)
6. [ ] Add "Run This" sections to all code examples

**Design Decisions Draft:**
```markdown
## üéì Design Decisions

### Decis√£o 1: Por que Bun Test em vez de Jest/Vitest?

**Alternativas:**
1. Jest - Test runner padr√£o do ecossistema Node.js
2. Vitest - Test runner r√°pido compat√≠vel com Jest
3. Bun Test - Test runner embutido no Bun ‚úÖ **ESCOLHIDO**

**Compara√ß√£o:**

| Crit√©rio | Jest | Vitest | Bun Test |
|----------|------|--------|----------|
| Velocidade | Lento | R√°pido | Mais r√°pido |
| Setup | npm install | npm install | Embutido |
| Compatibilidade | M√°xima | Alta | Boa |
| Watch Mode | Sim | Sim | Sim |
| Coverage | Sim | Sim | Sim |
| Mocking | Avan√ßado | Avan√ßado | B√°sico |
| Tamanho | Grande | M√©dio | Zero |

**Por que Bun Test:**
- ‚úÖ Performance: 100x mais r√°pido que Jest
- ‚úÖ Zero setup: J√° vem com Bun
- ÔøΩCompatibilidade: Projeto j√° usa Bun
- ‚úÖ Simplicidade: API simples e direta

**Quando usar Jest/Vitest:**
- Jest: Projeto Node.js legado
- Vitest: Projeto Vite + React
- Bun Test: Projeto Bun novo (nosso caso)

### Decis√£o 2: Testes de integra√ß√£o com APIs reais ou mocks?

**Abordagens:**
1. Sempre mocks - Isolamento total
2. Sempre APIs reais - Testes verdadeiros mas lentos
3. H√≠brido - Unit com mocks, integra√ß√£o com reais ‚úÖ **ESCOLHIDO**

**Estrat√©gia:**
- Unit tests: 100% mocks, r√°pidos, isolados
- Integra√ß√£o: APIs reais quando poss√≠vel, sen√£o mocks gravados
- E2E: Sempre APIs reais

### Decis√£o 3: Coverage target: 80%, 90%, ou 100%?

**Metas:**
- 100% coverage ‚ùå Impratic√°vel
- 90% coverage ‚ö†Ô∏è Custo/benef√≠cio question√°vel
- 80% coverage ‚úÖ **ESCOLHIDO** - Bom equil√≠brio

**Racional:**
- C√≥digo de UI √© dif√≠cil de testar (TUI)
- Error handling edge cases t√™m baixo ROI
- Type safety j√° previne muitos bugs
- Foco em c√≥digo cr√≠tico de neg√≥cio

### Decis√£o 4: TDD ou Test-After?

**Abordagens:**
1. TDD - Escreve testes antes do c√≥digo
2. Test-After - Escreve testes depois do c√≥digo
3. Test-During - Escreve testes durante desenvolvimento ‚úÖ **REALIDADE**

**O que fazemos:**
- Testes para c√≥digo novo: TDD idealmente
- Testes para c√≥digo existente: Test-after
- Bug fixes: Teste do bug antes de consertar (regression test)
```

---

## Phase 2: Code Quality & Documentation (Week 2)

**Goal:** Improve code quality and add missing documentation

### Sprint 2.1: Add Inline Code Documentation

**Files:** All source files in `src/`

**Tasks:**
1. [ ] Document all complex algorithms (backoff, health score, etc.)
2. [ ] Extract magic numbers to named constants with explanations
3. [ ] Add JSDoc comments to public API functions
4. [ ] Add "why" comments for architectural decisions
5. [ ] Document WebSocket message flow
6. [ ] Document rate limiting algorithm
7. [ ] Document TUI layout decisions

**Example - Add to `src/http.ts`:**
```typescript
/**
 * Fetch JSON with automatic retry and exponential backoff.
 *
 * Retry Strategy:
 * - Retries on 429 (rate limit) and 5xx (server errors)
 * - Maximum 2 retries by default (3 total attempts)
 * - Exponential backoff: 200ms * 2^(attempt-1) + random jitter
 * - Total timeout configured per request
 *
 * Rate Limiting:
 * - Respects Polymarket API rate limits automatically
 * - Uses token bucket algorithm per endpoint
 * - Waits when bucket is empty instead of failing
 *
 * @param url - Full URL to fetch
 * @param options - Fetch options including timeout, retry count, etc.
 * @returns Parsed JSON response
 * @throws HttpError on non-retryable failures or after all retries exhausted
 *
 * @example
 * const data = await fetchJson<MimeType>('https://api.example.com/data', {
 *   timeoutMs: 5000,
 *   retries: 3
 * });
 */
export async function fetchJson<T>(url: string, options: FetchOptions = {}): Promise<T> {
  // ... implementation
}

/**
 * Calculate exponential backoff delay with jitter.
 *
 * Formula: delay = (200ms * 2^(attempt-1)) + random(0, 100ms)
 *
 * Why exponential? Prevents thundering herd when service recovers.
 * All clients don't retry simultaneously.
 *
 * Why jitter? Adds randomness to prevent synchronized retry storms.
 * Even if multiple clients start at same time, they spread out.
 *
 * Timeline example:
 * - Attempt 1 fails ‚Üí wait 200ms + jitter ‚Üí try again
 * - Attempt 2 fails ‚Üí wait 400ms + jitter ‚Üí try again
 * - Attempt 3 succeeds
 *
 * @param attempt - Current attempt number (1-indexed)
 * @returns Promise that resolves after calculated delay
 */
async function backoff(attempt: number): Promise<void> {
  const base = 200 * Math.pow(2, attempt - 1);
  const jitter = Math.floor(Math.random() * 100);
  await new Promise((resolve) => setTimeout(resolve, base + jitter));
}
```

**Example - Add to `src/tui.ts`:**
```typescript
/**
 * Health scoring algorithm for market quality assessment.
 *
 * Scores markets from 0-100 based on three factors:
 * 1. Spread quality (35 points max) - Tighter spread = better
 * 2. Order book depth (35 points max) - More liquidity = better
 * 3. Trading volume (30 points max) - More activity = better
 *
 * Scoring bands:
 * - A (80-100): Excellent - Tight spread, deep book, high volume
 * - B (60-79): Good - Acceptable for most trading
 * - C (40-59): Fair - Usable but not ideal
 * - D (20-39): Poor - Risky to trade
 * - F (0-19): Terrible - Avoid trading
 *
 * @returns Object with score (0-100), letter grade (A-F), and display color
 */
function computeHealthScore(): { score: number; label: string; color: string } {
  // Constants for scoring - these weights sum to 100
  const SPREAD_WEIGHT_MAX = 35;   // Spread is most important for immediate trading
  const DEPTH_WEIGHT_MAX = 35;    // Depth indicates liquidity
  const VOLUME_WEIGHT_MAX = 30;   // Volume indicates activity

  // Spread scoring thresholds (in cents)
  const SPREAD_EXCELLENT = 0.01;  // <= 1 cent spread gets max points
  const SPREAD_GOOD = 0.03;       // <= 3 cents gets most points
  const SPREAD_FAIR = 0.05;       // <= 5 cents gets some points
  const SPREAD_POOR = 0.10;       // <= 10 cents gets minimal points

  // Depth scoring thresholds (in dollars)
  const DEPTH_EXCELLENT = 10000;
  const DEPTH_GOOD = 5000;
  const DEPTH_FAIR = 1000;
  const DEPTH_POOR = 100;

  // Volume scoring thresholds (in dollars)
  const VOLUME_EXCELLENT = 100000;
  const VOLUME_GOOD = 10000;
  const VOLUME_FAIR = 1000;
  const VOLUME_POOR = 100;

  let score = 0;

  // Calculate spread score (35 points max)
  const spread = bestBid !== undefined && bestAsk !== undefined ? bestAsk - bestBid : undefined;
  if (spread !== undefined) {
    if (spread <= SPREAD_EXCELLENT) score += SPREAD_WEIGHT_MAX;
    else if (spread <= SPREAD_GOOD) score += 25;
    else if (spread <= SPREAD_FAIR) score += 15;
    else if (spread <= SPREAD_POOR) score += 5;
  }

  // Calculate depth score (35 points max)
  const totalDepth = (orderbook?.bids?.reduce((sum, l) => sum + l.size, 0) ?? 0) +
                     (orderbook?.asks?.reduce((sum, l) => sum + l.size, 0) ?? 0);
  if (totalDepth > DEPTH_EXCELLENT) score += DEPTH_WEIGHT_MAX;
  else if (totalDepth > DEPTH_GOOD) score += 25;
  else if (totalDepth > DEPTH_FAIR) score += 15;
  else if (totalDepth > DEPTH_POOR) score += 5;

  // Calculate volume score (30 points max)
  const volume = focusMarket?.volume24hr ?? 0;
  if (volume > VOLUME_EXCELLENT) score += VOLUME_WEIGHT_MAX;
  else if (volume > VOLUME_GOOD) score += 20;
  else if (volume > VOLUME_FAIR) score += 10;
  else if (volume > VOLUME_POOR) score += 5;

  // Map score to letter grade
  const label = score >= 80 ? "A" : score >= 60 ? "B" : score >= 40 ? "C" : score >= 20 ? "D" : "F";

  // Map score to display color
  const color = score >= 80 ? THEME.success :
                score >= 60 ? THEME.accent :
                score >= 40 ? THEME.warning :
                THEME.danger;

  return { score, label, color };
}
```

### Sprint 2.2: Improve Type Safety

**Tasks:**
1. [ ] Replace `Record<string, unknown>` with proper interfaces
2. [ ] Add strict null checks where appropriate
3. [ ] Use discriminated unions for state types
4. [ ] Add branded types for IDs (ConditionId, TokenId, etc.)
5. [ ] Use `satisfies` for type validation

**Example - Before:**
```typescript
export type GammaEvent = Record<string, unknown>;
export type GammaMarket = Record<string, unknown>;
```

**Example - After:**
```typescript
export interface GammaEvent {
  id: string;
  slug?: string;
  title: string;
  description?: string;
  startDate?: string;
  endDate?: string;
  markets?: GammaMarket[];
  // ... other known fields
  [unknownField: string]: unknown;  // Allow unknown fields for extensibility
}

export interface GammaMarket {
  id?: string;
  conditionId?: string;
  condition_id?: string;  // Alternative naming
  question: string;
  slug?: string;
  outcomes?: string[] | string;  // Can be array or JSON string
  clobTokenIds?: string[] | string;  // Can be array or JSON string
  tokens?: Array<{
    token_id?: string;
    id?: string;
    outcome?: string;
  }>;
  volume24hr?: number | string;
  volume24h?: number | string;
  priceChange24hr?: number | string;
  [unknownField: string]: unknown;
}

// Branded types for IDs
export type ConditionId = string & { readonly __brand: unique symbol };
export type TokenId = string & { readonly __brand: unique symbol };
export type MarketId = string & { readonly __brand: unique symbol };

// Type-safe constructors
export function asConditionId(id: string): ConditionId {
  if (!id.startsWith('0x')) {
    throw new Error(`Invalid ConditionId: ${id}`);
  }
  return id as ConditionId;
}

export function asTokenId(id: string): TokenId {
  if (!id.startsWith('0x')) {
    throw new Error(`Invalid TokenId: ${id}`);
  }
  return id as TokenId;
}
```

### Sprint 2.3: Add "Run This" Sections to All Code Examples

**Tasks:**
1. [ ] Add expected output to all code blocks in Chapter 00-04
2. [ ] Add "Try This" interactive sections
3. [ ] Add "What You Should See" verification sections
4. [ ] Add "Common Mistakes" with error messages

**Example Pattern:**
```markdown
### Exemplo: Buscar Mercado da API

**C√≥digo:**
```typescript
import { fetchMarkets } from './src/api';

const markets = await fetchMarkets(5);
console.log(`Encontrados ${markets.length} mercados`);
markets.forEach((m, i) => {
  console.log(`${i + 1}. ${m.question}`);
});
```

**Para executar:**
```bash
# Salve como test-markets.ts
bun run test-markets.ts
```

**Sa√≠da esperada:**
```
Encontrados 5 mercados
1. Trump vencer√° as elei√ß√µes de 2024?
2. Elon Musk postar√° no X antes de 2025?
3. BTC estar√° acima de $100k em 2025?
4. Ethereum superar√° $5k em 2025?
5. Argentina vencer√° a Copa do Mundo?
```

**Verifica√ß√£o:**
- ‚úÖ Viu 5 mercados listados?
- ‚úÖ As perguntas est√£o em portugu√™s?
- ‚úÖ N√£o houve erros?

**Erros comuns:**
- `Error: Cannot find module './src/api'` - Voc√™ est√° no diret√≥rio errado
- `fetch failed` - Sem conex√£o com internet ou API fora do ar
- `undefined` - A API mudou, verifique a resposta
```

---

## Phase 3: Testing & Observability (Week 3)

**Goal:** Add comprehensive testing and structured logging

### Sprint 3.1: Implement Structured Logging

**Tasks:**
1. [ ] Create `src/logger.ts` with structured logging
2. [ ] Replace all console.log with logger
3. [ ] Add context to all error logs
4. [ ] Add request IDs for tracing
5. [ ] Implement log levels (info, warn, error)

**Implementation:**
```typescript
// src/logger.ts

export type LogLevel = "info" | "warn" | "error";

export interface LogContext {
  [key: string]: unknown;
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  context?: LogContext;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
  requestId?: string;
  userId?: string;
}

let requestIdCounter = 0;
export function generateRequestId(): string {
  return `req-${Date.now()}-${++requestIdCounter}`;
}

class Logger {
  private context: LogContext = {};

  withContext(additionalContext: LogContext): Logger {
    const logger = new Logger();
    logger.context = { ...this.context, ...additionalContext };
    return logger;
  }

  private log(level: LogLevel, message: string, error?: Error, additionalContext?: LogContext): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: { ...this.context, ...additionalContext },
    };

    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack,
      };
    }

    // In production, send to logging service
    // For now, just console with structured format
    const output = JSON.stringify(entry);
    switch (level) {
      case "info":
        console.info(output);
        break;
      case "warn":
        console.warn(output);
        break;
      case "error":
        console.error(output);
        break;
    }
  }

  info(message: string, context?: LogContext): void {
    this.log("info", message, undefined, context);
  }

  warn(message: string, context?: LogContext): void {
    this.log("warn", message, undefined, context);
  }

  error(message: string, error: Error | unknown, context?: LogContext): void {
    const err = error instanceof Error ? error : new Error(String(error));
    this.log("error", message, err, context);
  }
}

export const logger = new Logger();

// Convenience functions for specific components
export function createLogger(component: string): Logger {
  return new Logger().withContext({ component });
}
```

**Usage Example:**
```typescript
// src/api.ts
import { createLogger } from './logger';

const logger = createLogger('API');

export async function fetchMarkets(limit = 10): Promise<GammaMarket[]> {
  const requestId = generateRequestId();
  const start = performance.now();

  logger.info("Fetching markets", {
    requestId,
    limit,
    source: "Gamma API",
  });

  try {
    const url = withQuery(`${CONFIG.gammaBase}/markets`, {
      limit,
      closed: false,
      active: true,
    });

    const res = await fetchJson<unknown>(url);
    const markets = normalizeMarketsResponse(res);

    const duration = performance.now() - start;

    logger.info("Markets fetched successfully", {
      requestId,
      count: markets.length,
      durationMs: Math.round(duration),
    });

    return markets;
  } catch (error) {
    const duration = performance.now() - start;

    logger.error("Failed to fetch markets", error, {
      requestId,
      durationMs: Math.round(duration),
      limit,
    });

    throw error;
  }
}
```

### Sprint 3.2: Add HTTP Client Tests

**File:** `tests/http.test.ts`

**Tasks:**
1. [ ] Test retry on 429 status
2. [ ] Test retry on 5xx status
3. [ ] Test no retry on 4xx status
4. [ ] Test exponential backoff timing
5. [ ] Test rate limiting
6. [ ] Test timeout handling
7. [ ] Test error parsing

**Test Suite:**
```typescript
import { describe, it, expect, mock, beforeEach } from "bun:test";
import { fetchJson, HttpError } from "../src/http";

describe("fetchJson", () => {
  let mockFetch: ReturnType<typeof mock>;

  beforeEach(() => {
    mockFetch = mock(() => Promise.resolve({
      ok: true,
      json: () => Promise.resolve({ data: "test" }),
    }));
    global.fetch = mockFetch;
  });

  describe("retry behavior", () => {
    it("retries on 429 status", async () => {
      let attempts = 0;
      mockFetch.mockImplementation(() => {
        attempts++;
        if (attempts < 3) {
          return Promise.resolve({
            ok: false,
            status: 429,
            statusText: "Too Many Requests",
            text: () => Promise.resolve("Rate limit exceeded"),
          } as Response);
        }
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ success: true }),
        } as Response);
      });

      const result = await fetchJson("https://api.test.com/data");

      expect(result).toEqual({ success: true });
      expect(attempts).toBe(3);
    });

    it("retries on 5xx status", async () => {
      let attempts = 0;
      mockFetch.mockImplementation(() => {
        attempts++;
        if (attempts < 2) {
          return Promise.resolve({
            ok: false,
            status: 503,
            statusText: "Service Unavailable",
            text: () => Promise.resolve("Service unavailable"),
          } as Response);
        }
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ success: true }),
        } as Response);
      });

      const result = await fetchJson("https://api.test.com/data");

      expect(result).toEqual({ success: true });
      expect(attempts).toBe(2);
    });

    it("does not retry on 4xx status", async () => {
      let attempts = 0;
      mockFetch.mockImplementation(() => {
        attempts++;
        return Promise.resolve({
          ok: false,
          status: 404,
          statusText: "Not Found",
          text: () => Promise.resolve("Not found"),
        } as Response);
      });

      await expect(fetchJson("https://api.test.com/data")).rejects.toThrow(HttpError);
      expect(attempts).toBe(1);
    });

    it("respects max retries", async () => {
      let attempts = 0;
      mockFetch.mockImplementation(() => {
        attempts++;
        return Promise.resolve({
          ok: false,
          status: 503,
          statusText: "Service Unavailable",
          text: () => Promise.resolve("Service unavailable"),
        } as Response);
      });

      await expect(fetchJson("https://api.test.com/data", { retries: 2 })).rejects.toThrow(HttpError);
      expect(attempts).toBe(3); // Initial + 2 retries
    });
  });

  describe("exponential backoff", () => {
    it("waits exponentially longer between retries", async () => {
      const timestamps: number[] = [];
      mockFetch.mockImplementation(() => {
        timestamps.push(Date.now());
        return Promise.resolve({
          ok: false,
          status: 503,
          statusText: "Service Unavailable",
          text: () => Promise.resolve("Service unavailable"),
        } as Response);
      });

      try {
        await fetchJson("https://api.test.com/data", { retries: 2 });
      } catch {
        // Expected to fail
      }

      expect(timestamps.length).toBe(3);
      const delays = timestamps.slice(1).map((t, i) => t - timestamps[i]);

      // First retry should be ~200ms + jitter
      expect(delays[0]).toBeGreaterThanOrEqual(200);
      expect(delays[0]).toBeLessThan(400);

      // Second retry should be ~400ms + jitter
      expect(delays[1]).toBeGreaterThanOrEqual(400);
      expect(delays[1]).toBeLessThan(600);
    });
  });

  describe("timeout handling", () => {
    it("times out after configured duration", async () => {
      mockFetch.mockImplementation(() =>
        new Promise((resolve) => setTimeout(() => resolve({
          ok: true,
          json: () => Promise.resolve({ late: "response" }),
        } as Response), 5000))
      );

      await expect(
        fetchJson("https://api.test.com/data", { timeoutMs: 100 })
      ).rejects.toThrow();
    });
  });

  describe("error handling", () => {
    it("parses error response body", async () => {
      mockFetch.mockImplementation(() =>
        Promise.resolve({
          ok: false,
          status: 400,
          statusText: "Bad Request",
          text: () => Promise.resolve(JSON.stringify({ error: "Invalid parameter" })),
        } as Response)
      );

      const error = await expect(
        fetchJson("https://api.test.com/data")
      ).rejects.toThrow(HttpError);

      expect((error as HttpError).status).toBe(400);
    });
  });
});
```

### Sprint 3.3: Add Rate Limiter Tests

**File:** `tests/rateLimiter.test.ts`

**Tasks:**
1. [ ] Test token bucket behavior
2. [ ] Test window reset
3. [ ] Test concurrent requests
4. [ ] Test multiple rate limit rules
5. [ ] Test jitter calculation

### Sprint 3.4: Add WebSocket Client Tests

**File:** `tests/ws.test.ts`

**Tasks:**
1. [ ] Test connection
2. [ ] Test reconnection with backoff
3. [ ] Test message parsing
4. [ ] Test ping/pong handling
5. [ ] Test stale detection

---

## Phase 4: Polish & Validation (Week 4)

**Goal:** Final polish and validation

### Sprint 4.1: Add Search Functionality to Documentation

**Tasks:**
1. [ ] Investigate static site search options
2. [ ] Implement search index
3. [ ] Add search UI to README
4. [ ] Test search relevance

### Sprint 4.2: Create Troubleshooting Guide

**File:** `docs/TROUBLESHOOTING.md`

**Tasks:**
1. [ ] Document all common errors
2. [ ] Add solutions for each error
3. [ ] Add debugging steps
4. [ ] Add when to escalate

### Sprint 4.3: Performance Optimization

**Tasks:**
1. [ ] Profile application startup
2. [ ] Profile TUI rendering
3. [ ] Optimize hot paths
4. [ ] Add benchmarks

### Sprint 4.4: Final Validation

**Tasks:**
1. [ ] Run all test suites
2. [ ] Verify all code references
3. [ ] Check all examples run
4. [ ] Validate against guidelines
5. [ ] Create release checklist

---

## Success Criteria

### Phase 1 Success
- [ ] All chapters have checkpoints
- [ ] All chapters have Common Pitfalls
- [ ] All chapters have Troubleshooting
- [ ] All chapters have Design Decisions
- [ ] All code references verified
- [ ] Zero code reference errors

### Phase 2 Success
- [ ] All complex functions documented
- [ ] All magic numbers extracted
- [ ] Zero `Record<string, unknown>` in public API
- [ ] All code examples have expected output

### Phase 3 Success
- [ ] Structured logging implemented
- [ ] 80%+ test coverage
- [ ] All tests passing
- [ ] Zero console.log in production code

### Phase 4 Success
- [ ] Search functional
- [ ] Troubleshooting guide complete
- [ ] Performance benchmarks passing
- [ ] All guidelines verified

---

## Progress Tracking

**Current Phase:** Phase 1 - Complete Missing Documentation

**Overall Progress:** 0% (0/100 tasks completed)

**Phase Breakdown:**
- Phase 1: 0% (0/21 tasks)
- Phase 2: 0% (0/16 tasks)
- Phase 3: 0% (0/20 tasks)
- Phase 4: 0% (0/16 tasks)

**Next Milestone:** Complete Chapter 05 Checkpoints (Target: Day 2)

---

*This spec is a living document. Update tasks as you complete them.*

**Last Updated:** 2026-01-06
**Next Review:** After Phase 1 completion
