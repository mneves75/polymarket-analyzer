# Polymarket Analyzer - Engineering Execution Spec

> **Status:** Active | **Created:** 2026-01-06 | **Owner:** Development Team
>
> **"John Carmack is reviewing this. Make it count."**

---

## Document Overview

This is a **living execution specification** that will be updated as work progresses. It represents the comprehensive plan to bring the polymarket-analyzer documentation and codebase to industry-leading standards.

### Phase Structure

- **Phase 1:** Complete Missing Documentation (Week 1)
- **Phase 2:** Code Quality & Documentation (Week 2)
- **Phase 3:** Testing & Observability (Week 3)
- **Phase 4:** Polish & Validation (Week 4)

---

## Phase 1: Complete Missing Documentation (Week 1)

**Goal:** 100% completion of all documentation sections

### Sprint 1.1: Complete Chapter 05 (TUI)

**File:** `docs/learn/05-terminal-interface.md`

**Tasks:**
1. [ ] Add Checkpoints section (3-5 questions)
2. [ ] Add Common Pitfalls section (5-7 pitfalls)
3. [ ] Add Troubleshooting section (5-7 issues)
4. [ ] Add Design Decisions section (3-4 decisions)
5. [ ] Add External Resources section (5-7 links)
6. [ ] Fix code reference errors (verify utils.ts location)
7. [ ] Add "Run This" sections to all code examples

**Checkpoint Questions Draft:**
```markdown
## [CHECK] Checkpoint

1. What is the main difference between CLI, TUI, and GUI?
2. How do you create a basic component with Blessed?
3. What is smartCSR and when should you use it?
4. How do you capture keyboard input in Blessed?
5. What is the difference between tags like {bold} and style.fg?
```

**Common Pitfalls Draft:**
```markdown
## [WARNING] Common Pitfalls

### Pitfall 1: Forgetting screen.render()
**Problem:** You add components but nothing appears on the screen.
**Solution:** Always call screen.render() after modifying components.

### Pitfall 2: Memory Leaks with Timers
**Problem:** setInterval is never cleared, causing memory leaks.
**Solution:** Always keep references to timers and clean them on cleanup.

### Pitfall 3: Fixed vs Responsive Layout
**Problem:** Using fixed positions (top: 10) breaks on small terminals.
**Solution:** Use relative positions (top: "30%") when possible.

### Pitfall 4: Too Many Renders
**Problem:** Calling screen.render() on every WebSocket message causes lag.
**Solution:** Implement rate limiting or requestAnimationFrame.

### Pitfall 5: Ignoring Unicode/UTF-8
**Problem:** Special characters appear broken.
**Solution:** Configure locale and encoding correctly.

### Pitfall 6: Exiting without Cleanup
**Problem:** WebSocket stays open, timers keep running.
**Solution:** Always implement cleanup in process.on('SIGTERM').

### Pitfall 7: Non-Portable Colors
**Problem:** Colors work in one terminal but not another.
**Solution:** Test in multiple terminals, use basic colors (16 colors).
```

**Troubleshooting Draft:**
```markdown
## [FIX] Troubleshooting

### Issue: "Cannot find module 'blessed'"
**Symptoms:** Error when running bun --bun run dev
**Diagnosis:** Dependency not installed
**Solution:**
```bash
rm -rf node_modules
bun install
```

### Issue: TUI appears distorted
**Symptoms:** Lines don't align, overlapping text
**Diagnosis:** Terminal too small or non-monospaced font
**Solution:**
- Increase terminal size (minimum 80x24)
- Use monospaced font (Courier, Consolas, etc.)

### Issue: Keys don't work
**Symptoms:** Pressing keys does nothing
**Diagnosis:** Focus on wrong component or incorrect key binding
**Solution:**
- Verify that screen.key() is correct
- Use the correct key name (e.g., "C-c" not "ctrl-c")

### Issue: Slow performance
**Symptoms:** TUI freezes when updating
**Diagnosis:** Too many renders or heavy processing
**Solution:**
- Implement render throttling
- Move heavy processing to worker threads

### Issue: WebSocket reconnects infinitely
**Symptoms:** Message "reconnecting" appears constantly
**Diagnosis:** Incorrect URL or server down
**Solution:**
- Verify CONFIG.clobWsBase
- Test connection with wscat or similar tool

### Issue: Data doesn't update
**Symptoms:** Values remain static even with WebSocket connected
**Diagnosis:** Event handler not registered or incorrect assetId
**Solution:**
- Verify that onUpdate is being called
- Confirm assetId matches the expected token

### Issue: Error "content is not a function"
**Symptoms:** Error when trying to update content
**Diagnosis:** Trying to use .content() instead of .setContent()
**Solution:** Use setContent(string) not content()
```

**Design Decisions Draft:**
```markdown
## [LEARN] Design Decisions

### Decision 1: Why TUI (Terminal UI) instead of GUI?

**Alternatives Considered:**
1. Web App (React/Next.js) - Modern web interface
2. Desktop App (Electron) - Native desktop application
3. Simple CLI - Only commands without visual interface
4. TUI (Blessed) - Terminal interface [CHOSEN]

**Trade-offs:**

| Criteria | Web App | Electron | CLI | TUI | Winner |
|----------|---------|----------|-----|-----|--------|
| SSH Convenience | [X] Difficult | [X] Impossible | [OK] Easy | [OK] Easy | TUI |
| Performance | [!] Browser overhead | [X] Heavy | [OK] Light | [OK] Light | TUI |
| Distribution | [!] Server required | [!] Large binary | [OK] Single binary | [OK] Single binary | TUI |
| Rich visual | [OK] HTML/CSS | [OK] HTML/CSS | [X] No visual | [!] Limited | Web |
| "Hacker" appearance | [X] Corporate | [X] Common app | [!] Simple | [OK] Premium | TUI |
| System resources | [!] Limited | [OK] Full access | [OK] Full access | [OK] Full access | Tie |

**Why TUI was chosen:**
- [OK] Server focus: Heavy use in remote environments via SSH
- [OK] Lightweight: No browser/Electron overhead
- [OK] Distribution: Single binary, easy to install
- [OK] Aesthetics: "Professional hacker" appearance
- [OK] Performance: Instant rendering

**Scenarios where other options would be better:**
- Web App: For non-technical users who prefer visual interface
- Electron: If advanced graphics features were needed
- CLI: For automation and scripts

### Decision 2: Why Blessed instead of alternatives?

**Alternatives Considered:**
1. Blessed - ncurses library for Node.js [CHOSEN]
2. Ink - React for CLIs
3. Terminal-kit - Alternative library
4. Raw ANSI codes - No library

**Why Blessed:**
- [OK] Mature: Stable for years, widely used
- [OK] Simple: Direct API without abstraction layers
- [OK] Complete: Supports layouts, mouse, forms
- [OK] Documentation: Many examples and tutorials
- [OK] Compatibility: Works in Node.js and Bun

**Why not Ink:**
- Requires React knowledge
- Overhead for simple project
- Unnecessary abstraction

**Why not Terminal-kit:**
- Less popular/fewer features
- Different/more complex API

### Decision 3: 8-panel layout or simple layout?

**Approaches:**
1. Single panel - Shows only one thing at a time
2. Two panels - Radar + market detail
3. Eight panels - Radar, Market, Pulse, Orderbook, History, Holders, Alerts, Footer [CHOSEN]

**Why 8 panels:**
- [OK] Complete visibility: Everything important visible at once
- [OK] Efficiency: No need to navigate between screens
- [OK] Monitoring: View multiple markets simultaneously
- [OK] Professional: Looks like a real trading tool

**Trade-offs:**
- [X] Complexity: More code to manage
- [X] Space: Requires larger terminal (minimum 80x24, recommended 120x40)
- [X] Learning: More information to process

### Decision 4: Continuous update or on-demand?

**Approaches:**
1. Continuous polling - Updates every X seconds automatically [CHOSEN]
2. On-demand - Only updates when user presses 'r'
3. Hybrid - Some things continuous, others on-demand

**Why Continuous Polling:**
- [OK] Real-time: Data always fresh
- [OK] Convenience: User doesn't need to do anything
- [OK] WebSocket: We already receive real-time updates

**Update strategy:**
- Radar: 60 seconds (changes little)
- Orderbook: 3 seconds (changes a lot)
- History: 30 seconds (historical data)
- Holders: 60 seconds (changes little)
- WebSocket: Immediate (push)
```

### Sprint 1.2: Complete Chapter 06 (Errors & Rate Limiting)

**File:** `docs/learn/06-errors-rate-limiting.md`

**Tasks:**
1. [ ] Add Checkpoints section (3-5 questions)
2. [ ] Add Common Pitfalls section (5-7 pitfalls)
3. [ ] Add Troubleshooting section (5-7 issues)
4. [ ] Add Design Decisions section (3-4 decisions)
5. [ ] Add External Resources section (5-7 links)
6. [ ] Add "Run This" sections to all code examples

**Common Pitfalls Draft:**
```markdown
## [WARNING] Common Pitfalls

### Pitfall 1: "Swallowing" Errors (Silent Failures)
**Problem:**
```typescript
try {
  await riskyOperation();
} catch (err) {
  // Nothing - silent error
}
```
**Why it's bad:** You never know that something failed.
**Solution:**
```typescript
try {
  await riskyOperation();
} catch (err) {
  logger.error("Operation failed", { error: err });
  throw err;  // Propagates to caller
}
```

### Pitfall 2: Infinite Retry
**Problem:** Retry without max limit causes infinite loop.
**Solution:** Always have max retries and total timeout.

### Pitfall 3: Backoff Without Jitter
**Problem:** Multiple clients synchronize retries.
**Solution:** Add random jitter to backoff.

### Pitfall 4: Ignoring Rate Limits
**Problem:** Assuming API has no rate limit.
**Solution:** Implement rate limiting proactively.

### Pitfall 5: Timeout Too Long
**Problem:** 60-second timeout freezes the application.
**Solution:** Use short timeouts (5-10s) with retry.

### Pitfall 6: Not Logging Context
**Problem:** Logging only "Error: undefined"
**Solution:** Log endpoint, parameters, attempts, etc.

### Pitfall 7: Wrong Exponential Backoff
**Problem:** Grows too fast (2^10 = 1024x)
**Solution:** Cap at max time and retry limit.
```

### Sprint 1.3: Complete Chapter 07 (Tests)

**File:** `docs/learn/07-testing.md`

**Tasks:**
1. [ ] Add Checkpoints section (3-5 questions)
2. [ ] Add Common Pitfalls section (5-7 pitfalls)
3. [ ] Add Troubleshooting section (5-7 issues)
4. [ ] Add Design Decisions section (3-4 decisions)
5. [ ] Add External Resources section (5-7 links)
6. [ ] Add "Run This" sections to all code examples

**Design Decisions Draft:**
```markdown
## [LEARN] Design Decisions

### Decision 1: Why Bun Test instead of Jest/Vitest?

**Alternatives:**
1. Jest - Standard Node.js ecosystem test runner
2. Vitest - Fast Jest-compatible test runner
3. Bun Test - Bun's built-in test runner [CHOSEN]

**Comparison:**

| Criteria | Jest | Vitest | Bun Test |
|----------|------|--------|----------|
| Speed | Slow | Fast | Fastest |
| Setup | npm install | npm install | Built-in |
| Compatibility | Maximum | High | Good |
| Watch Mode | Yes | Yes | Yes |
| Coverage | Yes | Yes | Yes |
| Mocking | Advanced | Advanced | Basic |
| Size | Large | Medium | Zero |

**Why Bun Test:**
- [OK] Performance: 100x faster than Jest
- [OK] Zero setup: Comes with Bun
- [OK] Compatibility: Project already uses Bun
- [OK] Simplicity: Simple and direct API

**When to use Jest/Vitest:**
- Jest: Legacy Node.js project
- Vitest: Vite + React project
- Bun Test: New Bun project (our case)

### Decision 2: Integration tests with real APIs or mocks?

**Approaches:**
1. Always mocks - Total isolation
2. Always real APIs - True tests but slow
3. Hybrid - Unit with mocks, integration with real [CHOSEN]

**Strategy:**
- Unit tests: 100% mocks, fast, isolated
- Integration: Real APIs when possible, otherwise recorded mocks
- E2E: Always real APIs

### Decision 3: Coverage target: 80%, 90%, or 100%?

**Goals:**
- 100% coverage [X] Impractical
- 90% coverage [!] Questionable cost/benefit
- 80% coverage [OK] **CHOSEN** - Good balance

**Rationale:**
- UI code is hard to test (TUI)
- Error handling edge cases have low ROI
- Type safety already prevents many bugs
- Focus on business-critical code

### Decision 4: TDD or Test-After?

**Approaches:**
1. TDD - Write tests before code
2. Test-After - Write tests after code
3. Test-During - Write tests during development [REALITY]

**What we do:**
- Tests for new code: TDD ideally
- Tests for existing code: Test-after
- Bug fixes: Test the bug before fixing (regression test)
```

---

## Phase 2: Code Quality & Documentation (Week 2)

**Goal:** Improve code quality and add missing documentation

### Sprint 2.1: Add Inline Code Documentation

**Files:** All source files in `src/`

**Tasks:**
1. [ ] Document all complex algorithms (backoff, health score, etc.)
2. [ ] Extract magic numbers to named constants with explanations
3. [ ] Add JSDoc comments to public API functions
4. [ ] Add "why" comments for architectural decisions
5. [ ] Document WebSocket message flow
6. [ ] Document rate limiting algorithm
7. [ ] Document TUI layout decisions

**Example - Add to `src/http.ts`:**
```typescript
/**
 * Fetch JSON with automatic retry and exponential backoff.
 *
 * Retry Strategy:
 * - Retries on 429 (rate limit) and 5xx (server errors)
 * - Maximum 2 retries by default (3 total attempts)
 * - Exponential backoff: 200ms * 2^(attempt-1) + random jitter
 * - Total timeout configured per request
 *
 * Rate Limiting:
 * - Respects Polymarket API rate limits automatically
 * - Uses token bucket algorithm per endpoint
 * - Waits when bucket is empty instead of failing
 *
 * @param url - Full URL to fetch
 * @param options - Fetch options including timeout, retry count, etc.
 * @returns Parsed JSON response
 * @throws HttpError on non-retryable failures or after all retries exhausted
 *
 * @example
 * const data = await fetchJson<MimeType>('https://api.example.com/data', {
 *   timeoutMs: 5000,
 *   retries: 3
 * });
 */
export async function fetchJson<T>(url: string, options: FetchOptions = {}): Promise<T> {
  // ... implementation
}

/**
 * Calculate exponential backoff delay with jitter.
 *
 * Formula: delay = (200ms * 2^(attempt-1)) + random(0, 100ms)
 *
 * Why exponential? Prevents thundering herd when service recovers.
 * All clients don't retry simultaneously.
 *
 * Why jitter? Adds randomness to prevent synchronized retry storms.
 * Even if multiple clients start at same time, they spread out.
 *
 * Timeline example:
 * - Attempt 1 fails -> wait 200ms + jitter -> try again
 * - Attempt 2 fails -> wait 400ms + jitter -> try again
 * - Attempt 3 succeeds
 *
 * @param attempt - Current attempt number (1-indexed)
 * @returns Promise that resolves after calculated delay
 */
async function backoff(attempt: number): Promise<void> {
  const base = 200 * Math.pow(2, attempt - 1);
  const jitter = Math.floor(Math.random() * 100);
  await new Promise((resolve) => setTimeout(resolve, base + jitter));
}
```

**Example - Add to `src/tui.ts`:**
```typescript
/**
 * Health scoring algorithm for market quality assessment.
 *
 * Scores markets from 0-100 based on three factors:
 * 1. Spread quality (35 points max) - Tighter spread = better
 * 2. Order book depth (35 points max) - More liquidity = better
 * 3. Trading volume (30 points max) - More activity = better
 *
 * Scoring bands:
 * - A (80-100): Excellent - Tight spread, deep book, high volume
 * - B (60-79): Good - Acceptable for most trading
 * - C (40-59): Fair - Usable but not ideal
 * - D (20-39): Poor - Risky to trade
 * - F (0-19): Terrible - Avoid trading
 *
 * @returns Object with score (0-100), letter grade (A-F), and display color
 */
function computeHealthScore(): { score: number; label: string; color: string } {
  // Constants for scoring - these weights sum to 100
  const SPREAD_WEIGHT_MAX = 35;   // Spread is most important for immediate trading
  const DEPTH_WEIGHT_MAX = 35;    // Depth indicates liquidity
  const VOLUME_WEIGHT_MAX = 30;   // Volume indicates activity

  // Spread scoring thresholds (in cents)
  const SPREAD_EXCELLENT = 0.01;  // <= 1 cent spread gets max points
  const SPREAD_GOOD = 0.03;       // <= 3 cents gets most points
  const SPREAD_FAIR = 0.05;       // <= 5 cents gets some points
  const SPREAD_POOR = 0.10;       // <= 10 cents gets minimal points

  // Depth scoring thresholds (in dollars)
  const DEPTH_EXCELLENT = 10000;
  const DEPTH_GOOD = 5000;
  const DEPTH_FAIR = 1000;
  const DEPTH_POOR = 100;

  // Volume scoring thresholds (in dollars)
  const VOLUME_EXCELLENT = 100000;
  const VOLUME_GOOD = 10000;
  const VOLUME_FAIR = 1000;
  const VOLUME_POOR = 100;

  let score = 0;

  // Calculate spread score (35 points max)
  const spread = bestBid !== undefined && bestAsk !== undefined ? bestAsk - bestBid : undefined;
  if (spread !== undefined) {
    if (spread <= SPREAD_EXCELLENT) score += SPREAD_WEIGHT_MAX;
    else if (spread <= SPREAD_GOOD) score += 25;
    else if (spread <= SPREAD_FAIR) score += 15;
    else if (spread <= SPREAD_POOR) score += 5;
  }

  // Calculate depth score (35 points max)
  const totalDepth = (orderbook?.bids?.reduce((sum, l) => sum + l.size, 0) ?? 0) +
                     (orderbook?.asks?.reduce((sum, l) => sum + l.size, 0) ?? 0);
  if (totalDepth > DEPTH_EXCELLENT) score += DEPTH_WEIGHT_MAX;
  else if (totalDepth > DEPTH_GOOD) score += 25;
  else if (totalDepth > DEPTH_FAIR) score += 15;
  else if (totalDepth > DEPTH_POOR) score += 5;

  // Calculate volume score (30 points max)
  const volume = focusMarket?.volume24hr ?? 0;
  if (volume > VOLUME_EXCELLENT) score += VOLUME_WEIGHT_MAX;
  else if (volume > VOLUME_GOOD) score += 20;
  else if (volume > VOLUME_FAIR) score += 10;
  else if (volume > VOLUME_POOR) score += 5;

  // Map score to letter grade
  const label = score >= 80 ? "A" : score >= 60 ? "B" : score >= 40 ? "C" : score >= 20 ? "D" : "F";

  // Map score to display color
  const color = score >= 80 ? THEME.success :
                score >= 60 ? THEME.accent :
                score >= 40 ? THEME.warning :
                THEME.danger;

  return { score, label, color };
}
```

### Sprint 2.2: Improve Type Safety

**Tasks:**
1. [ ] Replace `Record<string, unknown>` with proper interfaces
2. [ ] Add strict null checks where appropriate
3. [ ] Use discriminated unions for state types
4. [ ] Add branded types for IDs (ConditionId, TokenId, etc.)
5. [ ] Use `satisfies` for type validation

**Example - Before:**
```typescript
export type GammaEvent = Record<string, unknown>;
export type GammaMarket = Record<string, unknown>;
```

**Example - After:**
```typescript
export interface GammaEvent {
  id: string;
  slug?: string;
  title: string;
  description?: string;
  startDate?: string;
  endDate?: string;
  markets?: GammaMarket[];
  // ... other known fields
  [unknownField: string]: unknown;  // Allow unknown fields for extensibility
}

export interface GammaMarket {
  id?: string;
  conditionId?: string;
  condition_id?: string;  // Alternative naming
  question: string;
  slug?: string;
  outcomes?: string[] | string;  // Can be array or JSON string
  clobTokenIds?: string[] | string;  // Can be array or JSON string
  tokens?: Array<{
    token_id?: string;
    id?: string;
    outcome?: string;
  }>;
  volume24hr?: number | string;
  volume24h?: number | string;
  priceChange24hr?: number | string;
  [unknownField: string]: unknown;
}

// Branded types for IDs
export type ConditionId = string & { readonly __brand: unique symbol };
export type TokenId = string & { readonly __brand: unique symbol };
export type MarketId = string & { readonly __brand: unique symbol };

// Type-safe constructors
export function asConditionId(id: string): ConditionId {
  if (!id.startsWith('0x')) {
    throw new Error(`Invalid ConditionId: ${id}`);
  }
  return id as ConditionId;
}

export function asTokenId(id: string): TokenId {
  if (!id.startsWith('0x')) {
    throw new Error(`Invalid TokenId: ${id}`);
  }
  return id as TokenId;
}
```

### Sprint 2.3: Add "Run This" Sections to All Code Examples

**Tasks:**
1. [ ] Add expected output to all code blocks in Chapter 00-04
2. [ ] Add "Try This" interactive sections
3. [ ] Add "What You Should See" verification sections
4. [ ] Add "Common Mistakes" with error messages

**Example Pattern:**
```markdown
### Example: Fetch Market from API

**Code:**
```typescript
import { fetchMarkets } from './src/api';

const markets = await fetchMarkets(5);
console.log(`Found ${markets.length} markets`);
markets.forEach((m, i) => {
  console.log(`${i + 1}. ${m.question}`);
});
```

**To run:**
```bash
# Save as test-markets.ts
bun --bun run test-markets.ts
```

**Expected output:**
```
Found 5 markets
1. Will Trump win the 2024 elections?
2. Will Elon Musk post on X before 2025?
3. Will BTC be above $100k in 2025?
4. Will Ethereum surpass $5k in 2025?
5. Will Argentina win the World Cup?
```

**Verification:**
- [OK] Did you see 5 markets listed?
- [OK] Are the questions displayed correctly?
- [OK] Were there no errors?

**Common errors:**
- `Error: Cannot find module './src/api'` - You are in the wrong directory
- `fetch failed` - No internet connection or API is down
- `undefined` - The API changed, check the response
```

---

## Phase 3: Testing & Observability (Week 3)

**Goal:** Add comprehensive testing and structured logging

### Sprint 3.1: Implement Structured Logging

**Tasks:**
1. [ ] Create `src/logger.ts` with structured logging
2. [ ] Replace all console.log with logger
3. [ ] Add context to all error logs
4. [ ] Add request IDs for tracing
5. [ ] Implement log levels (info, warn, error)

**Implementation:**
```typescript
// src/logger.ts

export type LogLevel = "info" | "warn" | "error";

export interface LogContext {
  [key: string]: unknown;
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  context?: LogContext;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
  requestId?: string;
  userId?: string;
}

let requestIdCounter = 0;
export function generateRequestId(): string {
  return `req-${Date.now()}-${++requestIdCounter}`;
}

class Logger {
  private context: LogContext = {};

  withContext(additionalContext: LogContext): Logger {
    const logger = new Logger();
    logger.context = { ...this.context, ...additionalContext };
    return logger;
  }

  private log(level: LogLevel, message: string, error?: Error, additionalContext?: LogContext): void {
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context: { ...this.context, ...additionalContext },
    };

    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack,
      };
    }

    // In production, send to logging service
    // For now, just console with structured format
    const output = JSON.stringify(entry);
    switch (level) {
      case "info":
        console.info(output);
        break;
      case "warn":
        console.warn(output);
        break;
      case "error":
        console.error(output);
        break;
    }
  }

  info(message: string, context?: LogContext): void {
    this.log("info", message, undefined, context);
  }

  warn(message: string, context?: LogContext): void {
    this.log("warn", message, undefined, context);
  }

  error(message: string, error: Error | unknown, context?: LogContext): void {
    const err = error instanceof Error ? error : new Error(String(error));
    this.log("error", message, err, context);
  }
}

export const logger = new Logger();

// Convenience functions for specific components
export function createLogger(component: string): Logger {
  return new Logger().withContext({ component });
}
```

**Usage Example:**
```typescript
// src/api.ts
import { createLogger } from './logger';

const logger = createLogger('API');

export async function fetchMarkets(limit = 10): Promise<GammaMarket[]> {
  const requestId = generateRequestId();
  const start = performance.now();

  logger.info("Fetching markets", {
    requestId,
    limit,
    source: "Gamma API",
  });

  try {
    const url = withQuery(`${CONFIG.gammaBase}/markets`, {
      limit,
      closed: false,
      active: true,
    });

    const res = await fetchJson<unknown>(url);
    const markets = normalizeMarketsResponse(res);

    const duration = performance.now() - start;

    logger.info("Markets fetched successfully", {
      requestId,
      count: markets.length,
      durationMs: Math.round(duration),
    });

    return markets;
  } catch (error) {
    const duration = performance.now() - start;

    logger.error("Failed to fetch markets", error, {
      requestId,
      durationMs: Math.round(duration),
      limit,
    });

    throw error;
  }
}
```

### Sprint 3.2: Add HTTP Client Tests

**File:** `tests/http.test.ts`

**Tasks:**
1. [ ] Test retry on 429 status
2. [ ] Test retry on 5xx status
3. [ ] Test no retry on 4xx status
4. [ ] Test exponential backoff timing
5. [ ] Test rate limiting
6. [ ] Test timeout handling
7. [ ] Test error parsing

**Test Suite:**
```typescript
import { describe, it, expect, mock, beforeEach } from "bun:test";
import { fetchJson, HttpError } from "../src/http";

describe("fetchJson", () => {
  let mockFetch: ReturnType<typeof mock>;

  beforeEach(() => {
    mockFetch = mock(() => Promise.resolve({
      ok: true,
      json: () => Promise.resolve({ data: "test" }),
    }));
    global.fetch = mockFetch;
  });

  describe("retry behavior", () => {
    it("retries on 429 status", async () => {
      let attempts = 0;
      mockFetch.mockImplementation(() => {
        attempts++;
        if (attempts < 3) {
          return Promise.resolve({
            ok: false,
            status: 429,
            statusText: "Too Many Requests",
            text: () => Promise.resolve("Rate limit exceeded"),
          } as Response);
        }
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ success: true }),
        } as Response);
      });

      const result = await fetchJson("https://api.test.com/data");

      expect(result).toEqual({ success: true });
      expect(attempts).toBe(3);
    });

    it("retries on 5xx status", async () => {
      let attempts = 0;
      mockFetch.mockImplementation(() => {
        attempts++;
        if (attempts < 2) {
          return Promise.resolve({
            ok: false,
            status: 503,
            statusText: "Service Unavailable",
            text: () => Promise.resolve("Service unavailable"),
          } as Response);
        }
        return Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ success: true }),
        } as Response);
      });

      const result = await fetchJson("https://api.test.com/data");

      expect(result).toEqual({ success: true });
      expect(attempts).toBe(2);
    });

    it("does not retry on 4xx status", async () => {
      let attempts = 0;
      mockFetch.mockImplementation(() => {
        attempts++;
        return Promise.resolve({
          ok: false,
          status: 404,
          statusText: "Not Found",
          text: () => Promise.resolve("Not found"),
        } as Response);
      });

      await expect(fetchJson("https://api.test.com/data")).rejects.toThrow(HttpError);
      expect(attempts).toBe(1);
    });

    it("respects max retries", async () => {
      let attempts = 0;
      mockFetch.mockImplementation(() => {
        attempts++;
        return Promise.resolve({
          ok: false,
          status: 503,
          statusText: "Service Unavailable",
          text: () => Promise.resolve("Service unavailable"),
        } as Response);
      });

      await expect(fetchJson("https://api.test.com/data", { retries: 2 })).rejects.toThrow(HttpError);
      expect(attempts).toBe(3); // Initial + 2 retries
    });
  });

  describe("exponential backoff", () => {
    it("waits exponentially longer between retries", async () => {
      const timestamps: number[] = [];
      mockFetch.mockImplementation(() => {
        timestamps.push(Date.now());
        return Promise.resolve({
          ok: false,
          status: 503,
          statusText: "Service Unavailable",
          text: () => Promise.resolve("Service unavailable"),
        } as Response);
      });

      try {
        await fetchJson("https://api.test.com/data", { retries: 2 });
      } catch {
        // Expected to fail
      }

      expect(timestamps.length).toBe(3);
      const delays = timestamps.slice(1).map((t, i) => t - timestamps[i]);

      // First retry should be ~200ms + jitter
      expect(delays[0]).toBeGreaterThanOrEqual(200);
      expect(delays[0]).toBeLessThan(400);

      // Second retry should be ~400ms + jitter
      expect(delays[1]).toBeGreaterThanOrEqual(400);
      expect(delays[1]).toBeLessThan(600);
    });
  });

  describe("timeout handling", () => {
    it("times out after configured duration", async () => {
      mockFetch.mockImplementation(() =>
        new Promise((resolve) => setTimeout(() => resolve({
          ok: true,
          json: () => Promise.resolve({ late: "response" }),
        } as Response), 5000))
      );

      await expect(
        fetchJson("https://api.test.com/data", { timeoutMs: 100 })
      ).rejects.toThrow();
    });
  });

  describe("error handling", () => {
    it("parses error response body", async () => {
      mockFetch.mockImplementation(() =>
        Promise.resolve({
          ok: false,
          status: 400,
          statusText: "Bad Request",
          text: () => Promise.resolve(JSON.stringify({ error: "Invalid parameter" })),
        } as Response)
      );

      const error = await expect(
        fetchJson("https://api.test.com/data")
      ).rejects.toThrow(HttpError);

      expect((error as HttpError).status).toBe(400);
    });
  });
});
```

### Sprint 3.3: Add Rate Limiter Tests

**File:** `tests/rateLimiter.test.ts`

**Tasks:**
1. [ ] Test token bucket behavior
2. [ ] Test window reset
3. [ ] Test concurrent requests
4. [ ] Test multiple rate limit rules
5. [ ] Test jitter calculation

### Sprint 3.4: Add WebSocket Client Tests

**File:** `tests/ws.test.ts`

**Tasks:**
1. [ ] Test connection
2. [ ] Test reconnection with backoff
3. [ ] Test message parsing
4. [ ] Test ping/pong handling
5. [ ] Test stale detection

---

## Phase 4: Polish & Validation (Week 4)

**Goal:** Final polish and validation

### Sprint 4.1: Add Search Functionality to Documentation

**Tasks:**
1. [ ] Investigate static site search options
2. [ ] Implement search index
3. [ ] Add search UI to README
4. [ ] Test search relevance

### Sprint 4.2: Create Troubleshooting Guide

**File:** `docs/TROUBLESHOOTING.md`

**Tasks:**
1. [ ] Document all common errors
2. [ ] Add solutions for each error
3. [ ] Add debugging steps
4. [ ] Add when to escalate

### Sprint 4.3: Performance Optimization

**Tasks:**
1. [ ] Profile application startup
2. [ ] Profile TUI rendering
3. [ ] Optimize hot paths
4. [ ] Add benchmarks

### Sprint 4.4: Final Validation

**Tasks:**
1. [ ] Run all test suites
2. [ ] Verify all code references
3. [ ] Check all examples run
4. [ ] Validate against guidelines
5. [ ] Create release checklist

---

## Success Criteria

### Phase 1 Success
- [ ] All chapters have checkpoints
- [ ] All chapters have Common Pitfalls
- [ ] All chapters have Troubleshooting
- [ ] All chapters have Design Decisions
- [ ] All code references verified
- [ ] Zero code reference errors

### Phase 2 Success
- [ ] All complex functions documented
- [ ] All magic numbers extracted
- [ ] Zero `Record<string, unknown>` in public API
- [ ] All code examples have expected output

### Phase 3 Success
- [ ] Structured logging implemented
- [ ] 80%+ test coverage
- [ ] All tests passing
- [ ] Zero console.log in production code

### Phase 4 Success
- [ ] Search functional
- [ ] Troubleshooting guide complete
- [ ] Performance benchmarks passing
- [ ] All guidelines verified

---

## Progress Tracking

**Current Phase:** Phase 1 - Complete Missing Documentation

**Overall Progress:** 0% (0/100 tasks completed)

**Phase Breakdown:**
- Phase 1: 0% (0/21 tasks)
- Phase 2: 0% (0/16 tasks)
- Phase 3: 0% (0/20 tasks)
- Phase 4: 0% (0/16 tasks)

**Next Milestone:** Complete Chapter 05 Checkpoints (Target: Day 2)

---

*This spec is a living document. Update tasks as you complete them.*

**Last Updated:** 2026-01-06
**Next Review:** After Phase 1 completion

---

**Version:** 1.0.0
**Last Updated:** January 2026
